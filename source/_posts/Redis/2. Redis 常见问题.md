---
title: Redis常见缓存问题
date: {{ date }}
categories:
- Redis
---

## 缓存与数据库双写不一致

现象1：先修改数据库，再删除缓存，如果缓存删除失败，缓存中是旧数据，就会出现数据不一致。

解决1：延时双删，先删除缓存，再修改数据库，再删除缓存，如果修改数据库失败了，数据库是旧数据，缓存为空，数据一致。

现象2：在更新一个库存的时候，同时在读取这个库存，此时数据库修改还未完成，缓存中存储的就是旧的数据。

解决2：将数据库与缓存的更新和读取进行异步串行化。

请求发到Tomcat，Tomcat先发一条半消息给MQ，然后修改redis，最后提交MQ消息更新数据库。定时任务校验缓存与DB的一致性

![在这里插入图片描述](https://img-blog.csdnimg.cn/cb30446c17294f1e8b65fe99b2efb378.png)

通用设计：能异步就异步处理

## 缓存雪崩

> key集中过期导致短时间内大量请求落到数据库

解决：过期时间使用固定时间+随机值模式，稀释集中到期的key的数量

## 缓存穿透

> 查询一个一定不存在的数据，缓存不会命中

解决：空结果进行缓存，设置一个比较短的过期时间，比如说5分钟。

## 缓存击穿

> 超高热点的key过期导致短时间内大量请求落到数据库

解决：分布式锁

## Redis 大量key集中过期导致其他key读写变慢

主动过期：Redis内部维护一个定时任务，默认每隔100毫秒会从过期字典中随机取出20个key，删除过期的key，如果过期key的比例超过了25%，则继续获取20个key，删除过期的key，循环往复，直到过期key的比例下降到25%或者这次任务的执行耗时超过了25毫秒，才会退出循环

Redis的主动过期的定时任务，也是在Redis主线程中执行的，也就是说如果在执行主动过期的过程中，出现了需要大量删除过期key的情况，那么在业务访问时，必须等这个过期任务执行结束，才可以处理业务请求。此时就会出现，业务访问延时增大的问题，最大延迟为25毫秒。

解决方案是，在集中过期时增加一个随机时间，把这些需要过期的key的时间打散即可