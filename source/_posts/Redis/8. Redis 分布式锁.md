---
title: Redis分布式锁
date: {{ date }}
categories:
- Redis
---

https://juejin.cn/post/6844904106461495303

## redisson 实现分布式锁

```xml
<dependency>
    <groupId>org.redisson</groupId>
    <artifactId>redisson-spring-boot-starter</artifactId>
    <version>3.15.4</version>
</dependency>
```

```java
@Configuration
@EnableCaching
@EnableConfigurationProperties(RedisProperties.class)
public class RedissonConfig {

    private static final String PREFIX = "redis://";

    private static final String SSL_PREFIX = "rediss://";

    @Resource
    private RedisProperties redisProperties;

    @Bean
    public CacheManager cacheManager(RedissonClient redissonClient) {
        return new RedissonSpringCacheManager(redissonClient);
    }

    @Bean
    public RedissonClient redissonClient() {
        Config config = new Config();
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        // 解决jackson2无法反序列化LocalDateTime的问题
        om.disable(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS);
        om.registerModule(new JavaTimeModule());
        config.setCodec(new JsonJacksonCodec(om));
        RedisProperties.Cluster cluster = redisProperties.getCluster();
        if (cluster != null) {
            clusterConfig(config, cluster);
        } else {
            singleConfig(config);
        }
        return Redisson.create(config);
    }

    private void clusterConfig(Config config, RedisProperties.Cluster cluster){
        List<String> nodes = cluster.getNodes();
        if (redisProperties.getTimeout() == null) {
            redisProperties.setTimeout(Duration.ofSeconds(3));
        }
        config.useClusterServers()
                .addNodeAddress(nodes.toArray(new String[0]))
                .setConnectTimeout((int) redisProperties.getTimeout().toMillis())
                .setPassword(redisProperties.getPassword());
    }

    private void singleConfig(Config config){
        String prefix = redisProperties.isSsl() ? SSL_PREFIX : PREFIX;
        if (redisProperties.getTimeout() == null) {
            redisProperties.setTimeout(Duration.ofSeconds(3));
        }
        config.useSingleServer()
                .setAddress(prefix + redisProperties.getHost() + ":" + redisProperties.getPort())
                .setConnectTimeout((int) redisProperties.getTimeout().toMillis())
                .setDatabase(redisProperties.getDatabase())
                .setPassword(redisProperties.getPassword());
    }
}
```

```java
@Resource
private RedissonClient redissonClient;   

public void testLock() {
    RLock lock = redissonClient.getLock("lock_key");
    try {
        // 参数1：WAIT_TIME 等待锁释放的时间
        // 参数2：LEASE_TIME 超出该时间锁自动释放
        if (lock.tryLock(0, 60, TimeUnit.SECONDS)) {
            // 得到锁执行业务逻辑
        } else {
            throw BusinessException.of("提交过于频繁，请稍后再试");
        }
    } finally {
        // 运行业务逻辑时异常也要将锁释放掉
        lock.unlock();
    }
}
```

## redisson 看门狗

> 如果锁过期，但是业务还未执行完，通过看门狗就可以自动将锁续期

原理：Redisson通过一个后台线程（定时任务），会每隔10秒检查一下，如果客户端还持有锁key，那么就会不断的延长锁key的生存时间。如果服务挂掉了，定时任务自然也就跑不下去了。

同时满足下面两个条件，Redisson才会启用看门狗机制

1. 当前线程获取锁成功
2. 未指定锁的超时时间，看门狗才生效；如果我们指定了锁超时时间（LEASE_TIME），则看门狗不会启动

自动续期底层还是一段LUA脚本，通过hexists指令判断锁是不是自己的锁，如果是的话，则通过pexpire指令将锁的过期时间给重置为30秒，返回1，表示自动续期成功；返回0，表示续期失败。

过了 10s 左右，判断到线程还持有着这把锁，即业务还没执行完，就会将锁的时间重新设置为 30s，返回true，然后通过递归，又过了10s，再一次续期，不断循环这个过程，直到锁被释放或者其它一些情况判断到当前线程已经没有持有这把锁之后，取消看门狗定时任务。