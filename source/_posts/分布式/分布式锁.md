---
title: 分布式锁
date: {{ date }}
categories:
- 分布式
tags:
- 分布式
---

## redis

### 锁实现

利用setnx的返回值特性，有值返回失败，无值返回成功，需要设置过期时间。

redisson：一种基于redis的封装好的分布式锁。

### 看门狗

有可能业务还在执行，锁到期了，这个时候可以在后台开一个守护线程对锁进行续期，即看门狗。

```java
@Async
public void renewal(){
    if (getkey == 我自己加的锁) {
        // 续期
        setnx key value ex 10
    }
}
```

### 单机故障问题

如果redis挂了，那么整个业务都会停滞，所以redis最好使用集群

### Redis主从集群的问题

服务A使用Redis Master加锁，此时锁还没同步到Slave，Master挂了，那么此时服务B来获取锁，Master挂了就从Slave获取，由于Slave没有锁，所以可以成功获取到，此时就出现了没锁上的问题。

解决上述问题：红锁

奇数台Redis，不做主从，从第一台开始加锁，过半则加锁成功。

举例：5台Redis，则加锁3台就成功，A服务加锁1、2、3台Redis成功，此时B服务进来，1、2、3台redis加过锁了就不能加了，只能加4、5台机器，由于没过半，B服务加锁失败。

5台中有Redis挂了怎么办，在程序中配好5台redis，3台redis加锁成功则成功，即使挂一台，剩下4台Redis还是大于3台，依旧可以正常运行。

### 红锁的问题

如果服务A在1、2、3台Redis加锁成功，此时第3台Redis挂了，重启后锁信息丢失，B服务就可以使用3、4、5获取到锁

解决：Redis部署手册写延迟启动（24H）

### JVM的STW问题

当JVM出现STW有可能导致看门狗没续上期。

解决1：鸵鸟算法

解决2：使用1台redis做锁，1台redis稳定性其实非常高

## 数据库实现

创建一张锁表（ID、锁的开始时间、锁的结束时间）

加锁：向锁表插入数据，不能插入，说明正在锁定中。

解锁：删除数据。

## zookeeper实现

有序临时节点 + watch监听

为每一个执行的线程创建一个有序的临时节点，为了确保有序性，在创建完节点，会再获取全部节点，会再获取全部节点，再重新进行一次排序，排序过程中，每个线程要判断自己的节点的序号是否是最小的。

如果是最小的，将会获取到锁，执行相关操作，释放锁

如果不是最小的，会监听到它的前一个节点，当它前一个节点被删除时，它就会获取锁，一次类推