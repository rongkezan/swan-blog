---
title: 计算机网络
date: {{ date }}
categories:
- 系统设计
---

## 网络体系结构

![在这里插入图片描述](https://img-blog.csdnimg.cn/4f0c882c6da342fc968cffb91b9ad0cf.png)

## 从浏览器地址栏输入 **url** 到显示主页的过程

1. DNS 解析：将域名解析成对应的 IP 地址。

2. TCP连接：与服务器通过三次握手，建立 TCP 连接

3. 向服务器发送 HTTP 请求

4. 服务器处理请求，返回HTTp响应

5. 浏览器解析并渲染页面

6. 断开连接：TCP 四次挥手，连接结束

## DNS 解析过程

![在这里插入图片描述](https://img-blog.csdnimg.cn/bec87e5e9f154c599efc64fcba4f9f41.png)

假设你要查询 www.baidu.com 的 IP 地址；

首先会查找浏览器的缓存,看看是否能找到 www.baidu.com 对应的IP地址，找到就直接返回；否则进行下一步；

将请求发往给本地DNS服务器，如果查找到也直接返回，否则继续进行下一步；

![在这里插入图片描述](https://img-blog.csdnimg.cn/012116ad4b174a078b20a492f485f08b.png)

## Websocket 和 socket 的区别

Socket 其实就是等于 IP 地址 + 端口 + 协议 。

具体来说，Socket 是一套标准，它完成了对 TCP/IP 的高度封装，屏蔽网络细节，以方便开发者更好地进行网络编程。

WebSocket 是一个持久化的协议，它是伴随 H5 而出的协议，用来解决 http 不支持持久化连接 的问题。

Socket 一个是 网编编程的标准接口 ，而 WebSocket 则是应用层通信协议。

## Http 1.0 1.1 2.0 3 的区别

>  HTTP/1.0 默认是短连接，可以强制开启，HTTP/1.1 默认长连接，HTTP/2.0 采用多路复用。

### HTTP/1.0

默认使用 短连接 ，每次请求都需要建立一个 TCP 连接。它可以设置 Connection: keep-alive 这个字段，强制开启长连接。

### HTTP/1.1

引入了持久连接，即 TCP 连接默认不关闭，可以被多个请求复用。分块传输编码，即服务端每产生一块数据，就发送一块，用” 流模式” 取代” 缓存模式”。管道机制，即在同一个 TCP 连接里面，客户端可以同时发送多个请求。

### HTTP/2.0

二进制协议，1.1 版本的头信息是文本（ASCII 编码），数据体可以是文本或者二进制；2.0 中，头信息和数据体都是二进制。

完全多路复用，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应。

报头压缩，HTTP 协议不带有状态，每次请求都必须附上所有信息。Http/2.0 引入了头信息压缩机制，使用 gzip 或 compress 压缩后再发送。

服务端推送，允许服务器未经请求，主动向客户端发送资源。

### HTTP/3

HTTP/3主要有两大变化，传输层基于**UDP**、使用**QUIC**保证**UDP**可靠性。HTTP/2存在的一些问题，比如重传等等，都是由于TCP本身的特性导致的，所以

HTTP/3在QUIC的基础上进行发展而来，QUIC（Quick UDP Connections）直译为快速UDP网络连接，底层使用UDP进行数据传输。

HTTP/3主要有这些特点：

- 使用UDP作为传输层进行通信
- 在UDP的基础上QUIC协议保证了HTTP/3的安全性，在传输的过程中就完成了TLS加密握手
- HTTPS 要建⽴⼀个连接，要花费 6 次交互，先是建⽴三次握⼿，然后是 TLS/1.3的三次握⼿。QUIC 直接把以往的 TCP 和 TLS/1.3 的 6 次交互合并成了 3 次，减少了交互次数。
- QUIC 有⾃⼰的⼀套机制可以保证传输的可靠性的。当某个流发⽣丢包时，只会阻塞这个流，其他流不会受到影响。

## HTTP 如何实现长连接

### 什么是 HTTP 的长连接？

1. HTTP 分为长连接和短连接， 本质上说的是 TCP 的长短连接 。TCP 连接是一个双向的通道，它是可以保持一段时间不关闭的，因此 TCP 连接才具有真正的长连接和短连接这一说法。

2. TCP 长连接可以复用一个 TCP 连接，来发起多次的 HTTP 请求，这样就可以减少资源消耗，比如一次请求 HTML，如果是短连接的话，可能还需要请求后续的JS/CSS。

### 如何设置长连接？

通过在头部（请求和响应头）设置 **Connection** 字段指定为 keep-alive ，HTTP/1.0协议支持，但是是默认关闭的，从 HTTP/1.1 以后，连接默认都是长连接。

### 在什么时候会超时呢？

- HTTP 一般会有 httpd 守护进程，里面可以设置 keep-alive timeout ，当 tcp 连接闲置超过这个时间就会关闭，也可以在 HTTP 的 header 里面设置超时时间
- TCP 的 keep-alive 包含三个参数，支持在系统内核的 net.ipv4 里面设置；当TCP 连接之后，闲置了 tcp_keepalive_time ，则会发生侦测包，如果没有收到对方的 ACK，那么会每隔 tcp_keepalive_intvl 再发一次，直到发送了tcp_keepalive_probes ，就会丢弃该连接。

## HTTPS

> 公私钥、数字证书、加密、对称加密、非对称加密

HTTPS的主要工作流程

1. 客户端发起 HTTPS 请求，连接到服务端的 443 端口。

2. 服务端有一套数字证书（证书内容有公钥、证书颁发机构、失效日期等）。

3. 服务端将自己的数字证书发送给客户端（公钥在证书里面，私钥由服务器持有）。

4. 客户端收到数字证书之后，会验证证书的合法性。如果证书验证通过，就会生成一个随机的对称密钥，用证书的公钥加密。

5. 客户端将公钥加密后的密钥发送到服务器。

6. 服务器接收到客户端发来的密文密钥之后，用自己之前保留的私钥对其进行非对称解密，解密之后就得到客户端的密钥，然后用客户端密钥对返回数据进行对称加密，酱紫传输的数据都是密文啦。

7. 服务器将加密后的密文返回到客户端。

8. 客户端收到后，用自己的密钥对其进行对称解密，得到服务器返回的数据。

![在这里插入图片描述](https://img-blog.csdnimg.cn/7c9291d2b833453c805f90bd2963eef0.png)

更加详尽的图

![在这里插入图片描述](https://img-blog.csdnimg.cn/fc3327d3968347da91006d93883dff0c.png)

### 客户端怎么校验证书的合法性

首先，服务端的证书从哪来的呢？

为了让服务端的公钥被⼤家信任，服务端的证书都是由 CA （Certificate Authority，证书认证机构）签名的，CA就是⽹络世界⾥的公安局、公证中⼼，具有极⾼的可信度，所以由它来给各个公钥签名，信任的⼀⽅签发的证书，那必然证书也是被信任的。

![在这里插入图片描述](https://img-blog.csdnimg.cn/e852ffd0e1ae4c67a741f891798de5c1.png)

CA 签发证书的过程，如上图左边部分：

⾸先 CA 会把持有者的公钥、⽤途、颁发者、有效时间等信息打成⼀个包，然后对这些信息进⾏ Hash 计算，得到⼀个 Hash 值；然后 CA 会使⽤⾃⼰的私钥将该 Hash 值加密，⽣成 Certificate Signature，也就是CA 对证书做了签名；最后将 Certificate Signature 添加在⽂件证书上，形成数字证书；

客户端校验服务端的数字证书的过程，如上图右边部分：

⾸先客户端会使⽤同样的 Hash 算法获取该证书的 Hash 值 H1；

通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使⽤CA 的公钥解密 Certificate Signature 内容，得到⼀个 Hash 值 H2 ；最后⽐较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

假如在HTTPS的通信过程中，中间人篡改了证书原文，由于他没有CA机构的私钥，所以CA公钥解密的内容就不一致。

### 加密算法

对称加密：DES, 3DES, AEC

非对称加密：公钥、私钥，公钥通过私钥生成

1. 明文 > 公钥加密 > 密文 > 私钥解密 > 明文
2. 明文 > 私钥加密 > 密文 > 公钥解密 > 明文

**流程**

第一次请求，服务器把公钥返回给客户端

第二次请求，客户端拿刚下发的公钥对数据加密，发送给服务器

**风险**

代理服务器拦截到这个请求，虽然解不开数据包，但是可以通过公钥加密发送一个伪请求

代理服务器还可以伪造公钥和私钥，浏览器无法判断公钥是不是真的服务器下发的

### 证书和数字签名

> 可以解决伪造公钥私钥的问题

Https中，客户端在走80端口前会先走443端口来获取服务端下发的证书，并生成加密的随机数给服务端

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210218212333383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

在向443发完请求之后，向80端口发请求

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210218205803436.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)