---
title: 秒杀系统设计
date: {{ date }}
categories:
- 系统设计
---

## 秒杀系统设计原则

尽早拦截

- 秒杀链接生成的时候，用户的请求可以不用全部放进来，对于流量特别大的情况，让大部分用户的请求从用户就近节点的 CDN 走，告知用户秒杀结束。只有少部分用户的请求放到中心节点来。
- 对于秒杀页面的加载，静态资源要尽可能在动静分离的前提下，尽可能使用页面缓存和从 CDN 去获取，以减缓对主系统的压力。
- 通过点击后按钮置灰、验证码、答题、token 等方式减少和延缓用户请求，也过滤掉那些脚本请求。
- 系统一定要具备成熟的流控机制，丢弃无法处理的请求。

系统隔离：秒杀系统要尽可能地不要影响到主要业务，因此这里面的 web 服务，要单独使用为秒杀服务配备的服务器。

## 秒杀系统具体设计

### 判断活动开始

创建一个指定时间的活动后，向 redis 存储一个值，值的过期时间 = 指定时间 - 过期时间

通过判断 redis 的值是否存在来判断活动是否开始

### 开始抢购

客户端：按钮置灰，防止重复点击

网关：通过 Nginx-lua 直接查询 redis，发现超量过多时直接返回用户 "已售空"

服务端：

1. 基于 UserId 去重，防止刷单
2. 缓存预热，将要查询的热点数据先放入redis中，防止大量请求直接打到DB
3. 维护一个请求计数，只通过比实际库存量稍大的请求到MQ里，其余请求响应 "已售空"
4. 数据库更新采用乐观锁，防止超卖

服务端伪代码

```java
/* MQ 生产者 */
if (!redis.exists(userId)){				// 过滤重复用户
    redis.set(userId, "1");
}
if(redis.decr(goodsId) < 0){
    return "已售空";
} else {
    mq.convertAndSet(userId, goodsId);	// 将符合条件的用户放到 MQ 消费
}

/* MQ 消费者 */
update my_goods set stock = stock - 1, version = version + 1 where id = 1 and version = 0;
```

