---
title: MQ 常见问题
date: {{ date }}
categories:
- 消息队列
---

## 消息堆积

当生产者生产的速度长时间远远大于消费的速度时，就会造成消息堆积。

- 消息堆积的影响
  - 可能导致新消息无法进入队列
  - 可以导致旧消息无法丢失
  - 消息等待的消费时间过长，超出了业务容忍范围
- 产生堆积的情况
  - 生产者突然大量发布消息
  - 消费者消费失败
  - 消费者出现性能瓶颈
- 解决办法
  - 排查消费者的性能瓶颈
  - 增加消费者的多线程处理
  - 部署多个消费者

**消息已经堆积如何解决**

消息队列堆积，想办法把消息转移到一个新的队列，增加服务器来慢慢消费。

## 消息丢失

消息生产者发送消息成功，但是MQ没有收到消息，消息在从生产者传输到MQ的过程中丢失，一般是由于网络不稳定等原因。

**解决方案**

1. 采用RabbitMQ的消息确认机制，当消息成功被MQ接收到时，会给生产者发送一个确认消息表示接收成功。

   RabbitMQ发送方消息确认模式有三种：普通确认模式，批量确认模式，异步监听确认模式。

   异步监听确认模式：边发送消息边进行确认，不影响主线程任务进行。

2. RabbitMQ持久化交换机、队列、消息，确保MQ服务重启时能从磁盘恢复对应的交换机、队列和消息。

   Spring整合后默认开启了交换机、队列、消息的持久化。

## 有序消费

**场景1**

当RabbitMQ采用Work Queue模式，此时只会有一个Queue但是会有多个Consumer，同时多个Consumer直接是竞争关系，此时就会出现MQ消息乱序的问题。

解决方案：生产者根据 ID 计算出一个 Hash 值，然后对队列的个数取余，可以让相同 ID 的所有操作压到同一个队列，且每个队列都只有一个消费者，此时就不会出现乱序的情况。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210126162412781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

**场景2**

当RabbitMQ采用简单队列模式的时候，如果消费者采用多线程处理消息，会出现消息乱序的问题。

解决方案：消费者拉取消息然后根据 ID 算出一个 Hash 然后把相同 ID 的数据压到同一个内存队列，让同一个线程去处理，保证有序。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210126162801750.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjEwMzAyNg==,size_16,color_FFFFFF,t_70)

## 重复消费

为了防止消息在消费端丢失，会采用手动确认MQ的方式来解决，但是会引出一个问题，消费者处理消息成功，回复MQ时由于网络不稳定等因素未成功，MQ认为消费者消费失败，会通过消息的重发导致重复消费。

解决方案：幂等

使用redis的setnx命令存储消息id，每次消费前先查询该消息id是否存在，如果存在证明已经消费过则不再进行消费。

> setnx(key,value)	如果key不存在则插入成功且返回1，如果key存在则不操作且返回0

